Hamiltonian MCMCを用いたCSTMの推定
Hamiltonian MCMC法
本ブログでは詳細な理論の説明は割愛します．詳しくは，「基礎からのベイズ統計学 ハミルトニアンモンテカルロ法による実践的入門」や，NealのMCMC using Hamiltonian Dynamicsを参照してください．
ここでは，できるだけ簡単にHamiltonian MCMC法のイメージを書きます．
以下はほとんど清水先生のブログからの引用です．
Hamiltonian MCMC法は，物理学のアナロジーを用いて推移確率を決めます．事後分布の形がガウス分布だと仮定すると，ガウス分布の平均の尤度関数は正規分布に比例し，事前分布に一様分布を仮定すると，事後分布は尤度と事前分布の積で表されるので，正規分布となります．
この乱数を生成したいとして，HMCでは事後分布の形状がわかることを利用します．
まず，事後分布の対数の符号反転，つまり情報量の関数を考えます．
ここで，玉を適当な場所において転がす事を考えます．そのとき，正規乱数によって転がす強さ（運動量）を決めます．強く弾くと一回遠くまで転がってまた落ちてきてというように幅広い範囲で転がり続けます．弱く弾くと，下のほうで転がってる状態になるでしょう．摩擦がなければ運動量と位置ネルギーの合計（これをハミルトニアンといいます）は一定になるように，ずっと転がり続けます．HMCでは転がす時間を予め決めておいて，その時間になったら玉を止めます．止まったところのX軸の値が，次のパラメータの値とする．という方法です．
次のパラメータは，前回のパラメータの位置からまた正規乱数によって決めた運動量で弾いてということを繰り返します。この「ある値から乱数で決めた強さで玉を弾いて，一定時間立って止めた場所が次のパラメータの値」という更新自体が，推移確率になっているということです．
HMCでは，基本的には密度の高いところ（下の方）に転がることが多くなり，たまに強く弾くことで事後分布の端のほうもサンプリングできる，そういうアルゴリズムになっています．また，密度の高いところから離れたパラメータが生成された場合，位置エネルギーが大きいため，広い範囲に転がり，密度の高いところにパラメータが生成された場合は，位置エネルギーが小さいため比較的近くを転がりやすくなります．このように，密度が高いところに集中するようになる一方，自己相関が低い乱数を生成することができます．
実際には，玉がどこにあるかを判別するために，時間を短い間隔で区切って，離散的に玉の状態を判断します．このとき，微小時間をepsilon，その判定を何回するかをLというハイパーパラメータで決めます．Lとepsilonの積が玉を転がす時間というわけです．
CSTM
CSTMは以前僕のブログで紹介しています．詳細は https://seiichiinoue.github.io/post/cstm/ を見てください．
CSTMの生成過程は次のようになります．
単語ベクトルをとし，文書ベクトルをとしたとき，どちらも同じ潜在空間上で考えているので，内積をとって，その近さによって単語の確率を操作するようなモデルです．
文書ごとに単語の確率をきめ細やかに変更できるのが特徴です．
HMCによるCSTMの推定
CSTMの事後分布は，Polya分布の積に従うので，Polya分布の対数の符号反転が位置エネルギー()となります．
また，HMCでは，以下のハミルトニアンを用いてパラメータの候補を受諾・棄却します．
ここで，はパラメータのベクトルで，pは運動量です．
次に，パラメータの移動を考えます．HMCでは，次の時点のパラメータは位置エネルギーの勾配を用いて計算されます．
理論の詳細は割愛しますが，ハミルトニアンが一定のところをうまく数値計算する手法として，リープフロッグ法が用いられます．
更新手順は簡単にまとめると次のようになります．
を初期化
位置エネルギーの勾配を使って次の時点のを計算
を使ってを計算
2と同様にを計算
それでは実装を行っていきます．コードはGithubに公開しています．以下では未定義の関数が現れますが，関数名で戻り値が推測できるものとして取り扱っています．
CSTMでは，推定パラメータが単語ベクトル，文書ベクトル，がの3つあるので，ランダムウォークMH法などと同様にそれぞれ独立にサンプリングして更新していきます．
以下では単語ベクトルの更新過程のみ掲載します．（他はほとんど一緒です）
まず，Step1のパラメータの初期化についてです．
ただし，予備実験の結果からとしました．
次に，位置エネルギーの勾配を計算します．しかしCSTMは事後分布の微分が閉じた式となっていないため，数値微分を用いて計算します．
テイラー展開による3点近似を用いて計算します．具体的には実際に値を左右に微小値だけ動かして，その間数値を計算し，勾配を求めます．（ただし計算量のオーダーがえぐいです．）
勾配が求まったので，次に勾配を用いてを更新します．0.5ステップ後のは次のように計算されます．
そして，これを使って単語ベクトルの計算をします．
そして，1ステップ後のを計算して，リープフロッグ法の1iterが終わりです．これをL(ハイパーパラメータ)回回して，遷移先を決定します．
また，遷移先の採択は，以前のパラメータでのハミルトニアンと，次時点のパラメータの候補のハミルトニアンを比較して行います．
これで以上です．あとは必要なepoch数回します．
実験もスモールコーパスに対しては行いましたが，通常のコーパスに対しては計算量が多すぎて無理でした．
特に数値微分の箇所の計算量のオーダーが高いので計算量を下げる方法など，改良を検討していきたいと思います．
