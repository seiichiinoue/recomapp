Binary Indexed Treeの実装
Binary Indexed Treeとは
簡単に説明すると，BIT，またはフェニック木は，ある変数列の部分和の計算と要素の更新を効率よくできる木構造です．
どういう時に嬉しいかというと，例を見るのが早いと思います．以下のような問題設定に適用できます．
AOJ - The Number of Inversions
AOJ - Range Sum Query
簡単にBITのアイデアを理解するために，以下のような基本的な問題を考えます．
個の変数
以下の2種類のクエリをで実現する
にを加える
prefix[1, a]のところの和を求める．
冒頭に述べたとおり，BITは木構造でデータを保持します．（実際は長さNの配列で実現します）
木構造は以下のようになっています．青いノードが実際に配列で管理する要素になります．
深さの二分木となっており，以下のような法則で配列に値を保持しています．
各ノードには，部分木の要素の和が格納されている．
それぞれのノードが管理している区間の長さを番号(10進)で表示したとき，二進数でみると，二進数の最も下の”1”が立っているビットが区間の長さに対応する．
見たらわかるとおりですが，このようなデータ構造にすることで，変数の更新は，最大でも木の深さ回の更新，区間の和の算出も同様に木の深さ回の計算，つまりで実現できそうです．
具体的に最大のケースを考えると，変数の更新は，の更新が変更回数が最大で，
の値を更新
親ノードのの値を更新
親ノードのの更新
親ノードのの更新
の4回で，の区間に足し算をすることになります．
また，区間の和では，が最大で，
をとる
を足す
を足す
という感じでこちらもオーダーに収まっています．
[補足] Nは2ベキではなくてもBITの構築は可能らしいです．
実装方法
冒頭でも少し触れたとおり，木構造を長さの配列でインデックスの振り方を工夫しながら表現します．
まず，indexの振り方ですが，以下のように各要素（ノード）の管理している区間の長さを二進表記にします．
すると，長さNの配列をBITとしたとき，BIT[x]が管理する区間の長さは，xの最も下の”1”が立っているビットになっていることがわかります．
例えば，BIT[4]が管理している区間の長さは，2で，4を2進表記にすると0110，最も下の”1”が立っているビットは2なので長さは2．
以下は計算方法の話になりますが，次のように最も下の”1”が立っているビットを取り出すことができるので覚えましょう．
また，変数の更新は次のようになります．ある要素を更新した時，次に更新すべき区間は，番号に区間の長さを足すともとまるということになります．
コードで書くと以下のようになります．
そして，区間の和の計算は以下のようになります．ある要素までの区間和を計算し始めた時，次に足すべき区間は番号から区間の長さを引いたものになります．
コードで書くと以下のようになります．
これらをまとめて，構造体にすると，
こんな感じになります．完成です．
実際に使用する際には，以下の2点に注意して使用しなければいけません．
数列の要素に0以下のものがあると要素の追加ができないので，下駄を履かせる必要があります．これは，bitの初期化の値を0以外の何かで代用することで対応できそうです．
数列のサイズはNよりも大きくないといけません．indexを1から始める際はN+1にしておけば大丈夫そうです．
おわりに
データ構造やアルゴリズムって理解するのはもちろんですが，説明するのって難しいですね．
そんなことより最近「青春ブタ野郎はバニーガール先輩の夢を見ない」を見たんですが，筆者は麻衣さんに恋をしてしまい，超えられない”次元の”壁を痛感しており大変辛い日々を過ごしています．恋愛の猛者はアドバイスいただけると幸いです．何卒よろしくお願いいたします．
参照
Binary Indexed Treeのはなし
転倒数アルゴリズム
