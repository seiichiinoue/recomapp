競プロ用ライブラリをC++で書く
C++で競プロの問題を解くようになって1ヶ月ほど経ち，そろそろ本番でも使用していきたいと思い，復習がてらPythonで書いていた競プロ用ライブラリをC++で書き換えたものをまとめました．
アルゴリズムの分類についてはけんちょんさんのこのレポジトリを参考にさせていただいています．
今回実装したアルゴリズムは以下になります．
数論系
最大公約数/最小公倍数
素因数分解
組み合わせ
ビット全探索
dp
レーベンシュタイン距離
グラフ理論系
ワーシャルフロイド法
ダイクストラ法
データ構造
UnionFind木
最大公約数
最大公約数はユークリッドの互除法を用いて以下のように求められます．
非負整数, について，その最大公約数をとする．
であるとき，
最小公倍数
最小公倍数は最大公約数を使って，と表せます．
素因数分解
素因数分解とは
自然数がとの他に正の約数を持たない場合を素数という
任意の自然数を素数の積で表すことを素因数分解という．
自然数を素因数分解するアルゴリズムは以下の通りになります．
を2で割り切れなくなるまで繰り返し割る
以降，3,4,5,6…と続けていく
繰り返しは割る数をとして，の間のみで良い．
ビット全探索
ビットを使った組み合わせを数え上げるアルゴリズムになります．組み合わせ系の問題に使えます．
ビットを使った全探索は，以下のような手続きになります．
個の部分集合は個存在することより，からのビットを考える．
それぞれのビットにおいて，立っているビットの位置を記録する
上記の作業において得られた集合が部分集合になっており，全ビットにこの処理を行うと全ての部分集合が得られる事になる．
実装は以下の通りです．
例えば，とすると，次のような結果が得られます．
レーベンシュタイン距離
編集距離とも言われる2つの文字列がどの程度異なっているかを示す距離の一種です．動的計画法を用いて算出されます．
1文字削った文字列の末尾にどのような文字列を追加すれば一致するかを見ることで，1文字削った文字列との距離から1文字加えた文字列との距離を求めることができる．
長さ0の文字列と長さの文字列の距離はである
以上の2点から帰納的に求めることができます．
ワーシャルフロイド法
重み付き有向グラフの全ペアの最短経路問題を多項式時間で解くアルゴリズムです．
入力は以下のものと仮定します．
(有向または無向)グラフ 
Eの各辺の長さ(コスト)
アルゴリズムは頂点からまでの経路と，頂点を経由した場合の経路とでコストの合計が小さい方を記録していく動的計画法になっています．
ダイクストラ法
ダイクストラ法はワーシャルフロイド法とは異なり，全点探索ではなく，単一始点の最良優先探索によるアルゴリズムになっています．
ワーシャルフロイド法ではだった計算量がになり，優先度付きキューを用いた実装を行えば，となります．
アルゴリズムは以下の通りです．
始点を選択する．始点から始点への距離は0．
始点から辿れるノードに対して最短距離を算出し，その中で最も距離が近いノードを決定する．すると，そのノードに対するそれ以外を経由した最短経路は存在しないことがわかるため，そのノードの最適解が決定する
次に距離が確定したノードを選択する
上記の処理と同様にそこから辿れるノードに対して最短距離を算出し，保持していた暫定的な視点からの距離より短い経路が存在することになるならば，値を更新する．
これらを繰り返す
実装は以下の通りです．
Union-Find木
Union-Find木は，グループ分けを木構造で管理するデータ構造です．同じグループに属する(=同じ木に属する)という木構造でグループわけをする際，以下の2点を高速に行うことができます．
要素と要素が同じグループに所属するかどうかを判定したい
要素と要素が同じグループに属する場合，要素の属するグループと要素の属するグループを併合する
以下，実装です
See Also
