今回 は ， コンパイル は 通っ た のに 実行 時 に エラー が 出 て しまっ た 件 について ． 
問題 の コード は こちら ． ちょっと ややこしい dp です （ 競 プロ です ね ） 
segfault 
segmentation fault と は ， アクセス が 許可 さ れ て い ない 方法 で メモリ 上 の 位置 に アクセス しよ う と する とき に 起こる エラー 条件 ． 
例えば ， read only の 位置 に 書き込み を しよ う と し た 時 や ， OS の 部分 を 上書き しよ う と し た 時 に 起こる ． C ++ だ と ， 初期 化 時 の 配列 の 大き さ を 超え て 要素 を 指定 しよ う と し た とき ( index error ) や ， ポインタ 変数 が 指し て いる アドレス が NULL の 時 ， また 再帰 が 深 すぎ たり 無限 再帰 が 起き て いる 場合 など に セグフォ が 発生 する ． 
デバッグ 
mac に は デフォルト で lldb という デバッガ が 入っ て いる ので それ を 使用 し て どこ で セグフォ が 起き て いる の か 確認 する ． ( linux だ と gdb で 実行 できる ) 
lldb の 使い方 は 簡単 で ， 対象 の コード を オプション を つけ て コンパイル し た のち ， で 実行 し ， コマンド を 実行 すれ ば デバッグ を 行っ て くれる ． 
実際 に 行っ て みる と 以下 の よう に なる ． 
dp という 配列 に アクセス し た とき に セグフォ が 起き て いる という こと が わかっ た ． 
C ++ で は ， グローバル 変数 は ヒープ に 取ら れる の に対して ， ローカル 変数 は スタック に 積ま れ て いく ． なので 関数 （ 今回 の 例 で は main 関数 ） など の 中 で は 大きな 配列 は 確保 でき ない らしい ． 
今回 は ， main 関数 の 中 で サイズ の 大きい 配列 を ローカル 変数 として 定義 し て い た の が よく なかっ た こと に なる ので ， 配列 を グローバル に 置く こと に する ． 
再度 デバッグ を 行う ． 
セグフォ が 解消 さ れ て いる こと が わかる ． 
補足 
は 非常 に 有能 で 様々 な check が できる ． 
backtrace : 関数 の 呼び出し 順 を 確認 ． lldb コマンド は ． 
frame n : backtrace で 表示 さ れ て いる 関数 の うち ， n 番目 の 関数 に 移動 ． lldb コマンド は ． 
info locals : ローカル 変数 の 一覧 を 確認 ． lldb コマンド は 
info args : 引数 の 一覧 を 確認 ． lldb コマンド は 
print val : 変数 val の 値 を 表示 
