競 プロ 用 ライブラリ を C ++ で 書く 
C ++ で 競 プロ の 問題 を 解く よう に なっ て 1 ヶ月 ほど 経ち ， そろそろ 本番 で も 使用 し て いき たい と 思い ， 復習 が てら Python で 書い て い た 競 プロ 用 ライブラリ を C ++ で 書き換え た もの を まとめ まし た ． 
アルゴリズム の 分類 について は けん ちょん さん の この レポジトリ を 参考 に さ せ て いただい て い ます ． 
今回 実装 し た アルゴリズム は 以下 に なり ます ． 
数 論 系 
最大公約数 / 最小公倍数 
素因数 分解 
組み合わせ 
ビット 全 探索 
dp 
レーベンシュタイン 距離 
グラフ 理論 系 
ワーシャルフロイド 法 
ダイクストラ 法 
データ 構造 
UnionFind 木 
最大公約数 
最大公約数 は ユークリッド の 互除 法 を 用い て 以下 の よう に 求め られ ます ． 
非負 整数 , について ， その 最大公約数 を と する ． 
で ある とき ， 
最小公倍数 
最小公倍数 は 最大公約数 を 使っ て ， と 表せ ます ． 
素因数 分解 
素因数 分解 と は 
自然 数 が と の 他 に 正 の 約数 を 持た ない 場合 を 素数 という 
任意 の 自然 数 を 素数 の 積 で 表す こと を 素因数 分解 と いう ． 
自然 数 を 素因数 分解 する アルゴリズム は 以下 の 通り に なり ます ． 
を 2 で 割り切れ なく なる まで 繰り返し 割る 
以降 ， 3 , 4 , 5 , 6 … と 続け て いく 
繰り返し は 割る 数 を として ， の 間 のみ で 良い ． 
ビット 全 探索 
ビット を 使っ た 組み合わせ を 数え上げる アルゴリズム に なり ます ． 組み合わせ 系 の 問題 に 使え ます ． 
ビット を 使っ た 全 探索 は ， 以下 の よう な 手続き に なり ます ． 
個 の 部分 集合 は 個 存在 する こと より ， から の ビット を 考える ． 
それぞれ の ビット において ， 立っ て いる ビット の 位置 を 記録 する 
上記 の 作業 において 得 られ た 集合 が 部分 集合 に なっ て おり ， 全 ビット に この 処理 を 行う と 全て の 部分 集合 が 得 られる 事 に なる ． 
実装 は 以下 の 通り です ． 
例えば ， と する と ， 次 の よう な 結果 が 得 られ ます ． 
レーベンシュタイン 距離 
編集 距離 と も 言わ れる 2 つ の 文字 列 が どの 程度 異なっ て いる か を 示す 距離 の 一 種 です ． 動的 計画 法 を 用い て 算出 さ れ ます ． 
1 文字 削っ た 文字 列 の 末尾 に どの よう な 文字 列 を 追加 すれ ば 一致 する か を 見る こと で ， 1 文字 削っ た 文字 列 と の 距離 から 1 文字 加え た 文字 列 と の 距離 を 求める こと が できる ． 
長 さ 0 の 文字 列 と 長 さ の 文字 列 の 距離 は で ある 
以上 の 2 点 から 帰納的 に 求める こと が でき ます ． 
ワーシャルフロイド 法 
重み 付き 有向グラフ の 全 ペア の 最短 経路 問題 を 多項式 時間 で 解く アルゴリズム です ． 
入力 は 以下 の もの と 仮定 し ます ． 
( 有向 または 無向 ) グラフ 
E の 各 辺 の 長 さ ( コスト ) 
アルゴリズム は 頂点 から まで の 経路 と ， 頂点 を 経由 し た 場合 の 経路 と で コスト の 合計 が 小さい 方 を 記録 し て いく 動的 計画 法 に なっ て い ます ． 
ダイクストラ 法 
ダイクストラ 法 は ワーシャルフロイド 法 と は 異なり ， 全 点 探索 で は なく ， 単一 始点 の 最良 優先 探索 による アルゴリズム に なっ て い ます ． 
ワーシャルフロイド 法 で は だっ た 計算 量 が に なり ， 優先 度 付き キュー を 用い た 実装 を 行え ば ， と なり ます ． 
アルゴリズム は 以下 の 通り です ． 
始点 を 選択 する ． 始点 から 始点 へ の 距離 は 0 ． 
始点 から 辿れる ノード に対して 最短 距離 を 算出 し ， その 中 で 最も 距離 が 近い ノード を 決定 する ． する と ， その ノード に対する それ 以外 を 経由 し た 最短 経路 は 存在 し ない こと が わかる ため ， その ノード の 最適 解 が 決定 する 
次に 距離 が 確定 し た ノード を 選択 する 
上記 の 処理 と 同様 に そこ から 辿れる ノード に対して 最短 距離 を 算出 し ， 保持 し て い た 暫定 的 な 視点 から の 距離 より 短い 経路 が 存在 する こと に なる なら ば ， 値 を 更新 する ． 
これら を 繰り返す 
実装 は 以下 の 通り です ． 
Union - Find 木 
Union - Find 木 は ， グループ 分け を 木 構造 で 管理 する データ 構造 です ． 同じ グループ に 属する (= 同じ 木 に 属する ) という 木 構造 で グループ わけ を する 際 ， 以下 の 2 点 を 高速 に 行う こと が でき ます ． 
要素 と 要素 が 同じ グループ に 所属 する か どう か を 判定 し たい 
要素 と 要素 が 同じ グループ に 属する 場合 ， 要素 の 属する グループ と 要素 の 属する グループ を 併合 する 
以下 ， 実装 です 
See Also 
